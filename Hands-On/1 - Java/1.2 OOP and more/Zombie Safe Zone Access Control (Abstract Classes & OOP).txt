import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = in.nextInt();
        List<Applicant> applicants = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            String name = in.next();
            int age = in.nextInt();
            String hasIdStr = in.next();
            int riskScore = in.nextInt();

            boolean hasId = hasIdStr.equalsIgnoreCase("Y");
            applicants.add(new Applicant(name, age, hasId, riskScore));
        }

        int maxRisk = in.nextInt();

        // Build rules (order matters)
        List<Rule> rules = new ArrayList<>();
        rules.add(new IdRule());
        rules.add(new RiskRule(maxRisk));

        SafeZoneGatekeeper gatekeeper = new SafeZoneGatekeeper(rules);

        for (Applicant applicant : applicants) {
            Decision decision = gatekeeper.evaluate(applicant);
            System.out.println(applicant.getName() + ": " + decision.getStatus() + " (" + decision.getReason() + ")");
        }

        in.close();
    }
}

/* =========================
   Models (Encapsulation)
   ========================= */

class Applicant {
    private String name;
    private int age;
    private boolean hasId;
    private int riskScore;

    public Applicant(String name, int age, boolean hasId, int riskScore) {
        this.name = name;
        this.age = age;
        this.hasId = hasId;
        this.riskScore = riskScore;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public boolean hasId() {
        return hasId;
    }

    public int getRiskScore() {
        return riskScore;
    }
}

class Decision {
    private String status; // ALLOW or DENY
    private String reason; // NO_ID, RISK_TOO_HIGH, ALLOWED

    public Decision(String status, String reason) {
        this.status = status;
        this.reason = reason;
    }

    public String getStatus() {
        return status;
    }

    public String getReason() {
        return reason;
    }
}

/* =========================
   Rules (Abstraction + Inheritance)
   ========================= */

abstract class Rule {
    public abstract Decision evaluate(Applicant applicant);
}

class IdRule extends Rule {
    @Override
    public Decision evaluate(Applicant applicant) {
        // TODO: If applicant has no ID, return DENY (NO_ID)
        // Otherwise, return ALLOW (ALLOWED)
        if (!applicant.hasId()){
            return new Decision("DENY", "NO_ID");
        }
        return new Decision("ALLOW", "ALLOWED");
    }
}

class RiskRule extends Rule {
    private int maxRisk;

    public RiskRule(int maxRisk) {
        this.maxRisk = maxRisk;
    }

    @Override
    public Decision evaluate(Applicant applicant) {
        // TODO: If applicant riskScore > maxRisk, return DENY (RISK_TOO_HIGH)
        // Otherwise, return ALLOW (ALLOWED)
        if (applicant.getRiskScore() > maxRisk) {
            return new Decision("DENY", "RISK_TOO_HIGH");
        }
        return new Decision("ALLOW", "ALLOWED");
    }
}

/* =========================
   Gatekeeper (Polymorphism)
   ========================= */

class SafeZoneGatekeeper {
    private List<Rule> rules;

    public SafeZoneGatekeeper(List<Rule> rules) {
        this.rules = rules;
    }

    public Decision evaluate(Applicant applicant) {
        // TODO: Evaluate rules in order.
        // First DENY should be returned immediately.
        // If none deny, return ALLOW (ALLOWED).
        for (Rule rule : rules) {
            Decision decision = rule.evaluate(applicant);
            if (decision.getStatus().equals("DENY")) {
                return decision;
            }
        }
        return new Decision("ALLOW", "ALLOWED");
    }
}