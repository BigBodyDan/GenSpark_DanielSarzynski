import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // Read number of threats
        int n = in.nextInt();
        List<Threat> threats = new ArrayList<>();

        // Read threats
        for (int i = 0; i < n; i++) {
            String id = in.next();
            int distance = in.nextInt();
            int speed = in.nextInt();
            int infectionLevel = in.nextInt();

            threats.add(new Threat(id, distance, speed, infectionLevel));
        }

        // Read rule thresholds
        int minDistance = in.nextInt();
        int maxSpeed = in.nextInt();
        int maxInfection = in.nextInt();

        // Build rules (order matters)
        List<ThreatRule> rules = new ArrayList<>();
        rules.add(new DistanceRule(minDistance));
        rules.add(new SpeedRule(maxSpeed));
        rules.add(new InfectionRule(maxInfection));

        ThreatAnalyzer analyzer = new ThreatAnalyzer(rules);

        // Evaluate each threat
        for (Threat threat : threats) {
            Classification result = analyzer.classifyThreat(threat);
            System.out.println(threat.getId() + ": " + result);
        }

        in.close();
    }
}

/* =========================
   Model (Encapsulation)
   ========================= */

class Threat {
    private String id;
    private int distance;
    private int speed;
    private int infectionLevel;

    public Threat(String id, int distance, int speed, int infectionLevel) {
        this.id = id;
        this.distance = distance;
        this.speed = speed;
        this.infectionLevel = infectionLevel;
    }

    public String getId() {
        return id;
    }

    public int getDistance() {
        return distance;
    }

    public int getSpeed() {
        return speed;
    }

    public int getInfectionLevel() {
        return infectionLevel;
    }
}

/* =========================
   Result Type
   ========================= */

enum Classification {
    SAFE,
    DANGEROUS
}

/* =========================
   Abstraction (Interface)
   ========================= */

interface ThreatRule {
    Classification classify(Threat threat);
}

/* =========================
   Rule Implementations (Inheritance)
   ========================= */

class DistanceRule implements ThreatRule {
    private int minDistance;

    public DistanceRule(int minDistance) {
        this.minDistance = minDistance;
    }

    @Override
    public Classification classify(Threat threat) {
        // TODO: Return DANGEROUS if threat distance <= minDistance, else SAFE
        if (threat.getDistance() <= minDistance) {
            return Classification.DANGEROUS;
        }
        return Classification.SAFE;
    }
}

class SpeedRule implements ThreatRule {
    private int maxSpeed;

    public SpeedRule(int maxSpeed) {
        this.maxSpeed = maxSpeed;
    }

    @Override
    public Classification classify(Threat threat) {
        // TODO: Return DANGEROUS if threat speed >= maxSpeed, else SAFE
        if (threat.getSpeed() >= maxSpeed) {
            return Classification.DANGEROUS;
        }
        return Classification.SAFE;
    }
}

class InfectionRule implements ThreatRule {
    private int maxInfection;

    public InfectionRule(int maxInfection) {
        this.maxInfection = maxInfection;
    }

    @Override
    public Classification classify(Threat threat) {
        if (threat.getInfectionLevel() >= maxInfection) {
            return Classification.DANGEROUS;
        }
        return Classification.SAFE;
    }
}

/* =========================
   Analyzer (Polymorphism)
   ========================= */

class ThreatAnalyzer {
    private List<ThreatRule> rules;

    public ThreatAnalyzer(List<ThreatRule> rules) {
        this.rules = rules;
    }

    public Classification classifyThreat(Threat threat) {
        // TODO:
        // Apply rules in order.
        // If any rule returns DANGEROUS, stop and return DANGEROUS.
        // Otherwise return SAFE.
        for (ThreatRule rule : rules) {
            Classification result = rule.classify(threat);
            if (result == Classification.DANGEROUS) {
                return Classification.DANGEROUS;
            }
        }
        return Classification.SAFE;
    }
}